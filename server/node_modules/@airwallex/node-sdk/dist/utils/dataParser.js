"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.primitives = void 0;
exports.parseDataToType = parseDataToType;
exports.parseData = parseData;
const models_1 = require("../model/models");
exports.primitives = ['string', 'boolean', 'double', 'integer', 'long', 'float', 'number', 'any', 'object'];
const nullableSuffix = ' | null';
const optionalSuffix = ' | undefined';
const arrayPrefix = 'Array<';
const arraySuffix = '>';
const mapPrefix = '{ [key: string]: ';
const mapSuffix = '; }';
function startsWith(str, match) {
    return str.substring(0, match.length) === match;
}
function endsWith(str, match) {
    return str.length >= match.length && str.substring(str.length - match.length) === match;
}
function parseDataToType(rawdata, typeName) {
    const transformedData = parseData(rawdata, typeName);
    return transformedData;
}
function parseData(data, typeName) {
    if (data === undefined || data === null) {
        return data;
    }
    if (typeName && exports.primitives.indexOf(typeName.toLowerCase()) !== -1) {
        return data;
    }
    if (typeName && !models_1.typeMap[typeName]) {
        if (endsWith(typeName, nullableSuffix)) {
            const subType = typeName.slice(0, -nullableSuffix.length);
            return parseData(data, subType);
        }
        else if (endsWith(typeName, optionalSuffix)) {
            const subType = typeName.slice(0, -optionalSuffix.length);
            return parseData(data, subType);
        }
        else if (startsWith(typeName, arrayPrefix)) {
            const subType = typeName.slice(arrayPrefix.length, -arraySuffix.length);
            const transformedData = [];
            for (let index = 0; index < data.length; index++) {
                const datum = data[index];
                const transformedDatum = parseData(datum, subType);
                transformedData.push(transformedDatum);
            }
            return transformedData;
        }
        else if (startsWith(typeName, mapPrefix)) {
            const subType = typeName.slice(mapPrefix.length, -mapSuffix.length);
            const transformedData = {};
            for (const key in data) {
                const transformedDatum = parseData(data[key], subType);
                transformedData[key] = transformedDatum;
            }
            return transformedData;
        }
        else if (typeName === 'Date') {
            return new Date(data).toISOString();
        }
    }
    if (!typeName || !models_1.typeMap[typeName]) {
        return data;
    }
    const modelTypeMap = models_1.typeMap[typeName];
    const result = {};
    for (const attr of modelTypeMap) {
        const propName = attr.name;
        const propType = attr.type;
        const propValue = data[propName];
        if (propValue === undefined) {
            continue;
        }
        if (!models_1.enumsMap[propType]) {
            const transformedDatum = parseData(propValue, propType);
            result[propName] = transformedDatum;
        }
        else {
            const validValues = models_1.enumsMap[propType];
            if (validValues && typeof propValue === 'string') {
                if (validValues.includes(propValue)) {
                    result[propName] = propValue;
                }
                else {
                    result[propName] = 'UNKNOWN';
                }
            }
        }
    }
    return result;
}
//# sourceMappingURL=dataParser.js.map